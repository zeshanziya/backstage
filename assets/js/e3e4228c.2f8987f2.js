/*! For license information please see e3e4228c.2f8987f2.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[437137],{787201:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var a=n(824246),o=n(511151);const i={id:"extending-the-model",title:"Extending the model",description:"Documentation on extending the catalog model"},s=void 0,r={id:"features/software-catalog/extending-the-model",title:"Extending the model",description:"Documentation on extending the catalog model",source:"@site/../docs/features/software-catalog/extending-the-model.md",sourceDirName:"features/software-catalog",slug:"/features/software-catalog/extending-the-model",permalink:"/docs/features/software-catalog/extending-the-model",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/features/software-catalog/extending-the-model.md",tags:[],version:"current",frontMatter:{id:"extending-the-model",title:"Extending the model",description:"Documentation on extending the catalog model"},sidebar:"docs",previous:{title:"Well-known Statuses",permalink:"/docs/features/software-catalog/well-known-statuses"},next:{title:"External integrations",permalink:"/docs/features/software-catalog/external-integrations"}},l={},c=[{value:"Adding a New apiVersion of an Existing Kind",id:"adding-a-new-apiversion-of-an-existing-kind",level:2},{value:"Adding a New Kind",id:"adding-a-new-kind",level:2},{value:"Adding a New Type of an Existing Kind",id:"adding-a-new-type-of-an-existing-kind",level:2},{value:"Changing the Validation Rules for The Entity Envelope or Metadata Fields",id:"changing-the-validation-rules-for-the-entity-envelope-or-metadata-fields",level:2},{value:"Changing the Validation Rules for Core Entity Fields",id:"changing-the-validation-rules-for-core-entity-fields",level:2},{value:"Adding New Fields to the Metadata Object",id:"adding-new-fields-to-the-metadata-object",level:2},{value:"Adding New Fields to the Spec Object of an Existing Kind",id:"adding-new-fields-to-the-spec-object-of-an-existing-kind",level:2},{value:"Adding a New Annotation",id:"adding-a-new-annotation",level:2},{value:"Adding a New Label",id:"adding-a-new-label",level:2},{value:"Adding a New Relation Type",id:"adding-a-new-relation-type",level:2},{value:"Using a Well-Known Relation Type for a New Purpose",id:"using-a-well-known-relation-type-for-a-new-purpose",level:2},{value:"Adding a New Status field",id:"adding-a-new-status-field",level:2},{value:"Adding a New Status Item Type",id:"adding-a-new-status-item-type",level:2},{value:"Referencing different environments with the model",id:"referencing-different-environments-with-the-model",level:2},{value:"Implementing custom model extensions",id:"implementing-custom-model-extensions",level:2},{value:"Creating a custom entity definition",id:"creating-a-custom-entity-definition",level:3},{value:"Building a custom processor for the entity",id:"building-a-custom-processor-for-the-entity",level:3}];function d(e){const t=Object.assign({p:"p",a:"a",ul:"ul",li:"li",em:"em",code:"code",h2:"h2",blockquote:"blockquote",h3:"h3",pre:"pre"},(0,o.ah)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["The Backstage catalog ",(0,a.jsx)(t.a,{href:"/docs/features/software-catalog/descriptor-format",children:"entity data model"})," is based on the\n",(0,a.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/",children:"Kubernetes objects format"}),",\nand borrows a lot of its semantics as well. This page describes those semantics\nat a higher level and how to extend them to fit your organization."]}),"\n",(0,a.jsx)(t.p,{children:"Backstage comes with a number of catalog concepts out of the box:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["There are a number of builtin versioned ",(0,a.jsx)(t.em,{children:"kinds"}),", such as ",(0,a.jsx)(t.code,{children:"Component"}),", ",(0,a.jsx)(t.code,{children:"User"}),"\netc. These encapsulate the high level concept of an entity, and define the\nschema for its entity definition data."]}),"\n",(0,a.jsxs)(t.li,{children:["An entity has both a ",(0,a.jsx)(t.em,{children:"metadata"})," object and a ",(0,a.jsx)(t.em,{children:"spec"})," object at the root."]}),"\n",(0,a.jsxs)(t.li,{children:["Each kind may or may not have a ",(0,a.jsx)(t.em,{children:"type"}),". For example, there are several well\nknown types of component, such as ",(0,a.jsx)(t.code,{children:"service"})," and ",(0,a.jsx)(t.code,{children:"website"}),". These clarify the\nmore detailed nature of the entity, and may affect what features are exposed\nin the interface."]}),"\n",(0,a.jsxs)(t.li,{children:["Entities may have a number of ",(0,a.jsx)(t.em,{children:(0,a.jsx)(t.a,{href:"/docs/features/software-catalog/well-known-annotations",children:"annotations"})})," on\nthem. These can be added either by humans into the descriptor files, or added\nby automated processes when the entity is ingested into the catalog."]}),"\n",(0,a.jsxs)(t.li,{children:["Entities may have a number of ",(0,a.jsx)(t.em,{children:"labels"})," on them."]}),"\n",(0,a.jsxs)(t.li,{children:["Entities may have a number of ",(0,a.jsx)(t.em,{children:"relations"}),", expressing how they relate to each\nother in different ways."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"We'll list different possibilities for extending this below."}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-apiversion-of-an-existing-kind",children:"Adding a New apiVersion of an Existing Kind"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"I want to evolve this core kind, tweaking the semantics a bit so I will bump\nthe apiVersion a step"'}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["\"This core kind is a decent fit but we want to evolve it at will so we'll move\nit to our own company's apiVersion space and use that instead of\n",(0,a.jsx)(t.code,{children:"backstage.io"}),'."']}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"backstage.io"})," apiVersion space is reserved for use by the Backstage\nmaintainers. Please do not change or add versions within that space."]}),"\n",(0,a.jsxs)(t.p,{children:["If you add an ",(0,a.jsx)(t.a,{href:"/docs/features/software-catalog/descriptor-format#apiversion-and-kind-required",children:"apiVersion"}),"\nspace of your own, you are effectively branching out from the underlying kind\nand making your own. An entity kind is identified by the apiVersion + kind pair,\nso even though the resulting entity may be similar to the core one, there will\nbe no guarantees that plugins will be able to parse or understand its data. See\nbelow about adding a new kind."]}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-kind",children:"Adding a New Kind"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"The kinds that come with the package are lacking. I want to model this other\nthing that is a poor fit for either of the builtins."'}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["\"This core kind is a decent fit but we want to evolve it at will so we'll move\nit to our own company's apiVersion space and use that instead of\n",(0,a.jsx)(t.code,{children:"backstage.io"}),'."']}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["A ",(0,a.jsx)(t.a,{href:"/docs/features/software-catalog/descriptor-format#apiversion-and-kind-required",children:"kind"})," is an overarching\nfamily, or an idea if you will, of entities that also share a schema. Backstage\ncomes with a number of builtin ones that we believe are useful for a large\nvariety of needs that one may want to model in Backstage. The primary ambition\nis to map things to these kinds, but sometimes you may want or need to extend\nbeyond them."]}),"\n",(0,a.jsxs)(t.p,{children:["Introducing a new apiVersion is basically the same as adding a new kind. Bear in\nmind that most plugins will be compiled against the builtin\n",(0,a.jsx)(t.code,{children:"@backstage/catalog-model"})," package and have expectations that kinds align with\nthat."]}),"\n",(0,a.jsxs)(t.p,{children:["The catalog backend itself, from a storage and API standpoint, does not care\nabout the kind of entities it stores. Extending with new kinds is mainly a\nmatter of permitting them to pass validation when building the backend catalog\nusing the ",(0,a.jsx)(t.code,{children:"CatalogBuilder"}),", and then to make plugins be able to understand the\nnew kind."]}),"\n",(0,a.jsxs)(t.p,{children:["For the consuming side, it's a different story. Adding a kind has a very large\nimpact. The very foundation of Backstage is to attach behavior and views and\nfunctionality to entities that we ascribe some meaning to. There will be many\nplaces where code checks ",(0,a.jsx)(t.code,{children:"if (kind === 'X')"})," for some hard coded ",(0,a.jsx)(t.code,{children:"X"}),", and casts\nit to a concrete type that it imported from a package such as\n",(0,a.jsx)(t.code,{children:"@backstage/catalog-model"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"If you want to model something that doesn't feel like a fit for either of the\nbuiltin kinds, feel free to reach out to the Backstage maintainers to discuss\nhow to best proceed."}),"\n",(0,a.jsxs)(t.p,{children:["If you end up adding that new kind, you must namespace its ",(0,a.jsx)(t.code,{children:"apiVersion"}),"\naccordingly with a prefix that makes sense, typically based on your organization\nname - e.g. ",(0,a.jsx)(t.code,{children:"my-company.net/v1"}),". Also do pick a new ",(0,a.jsx)(t.code,{children:"kind"})," identifier that does\nnot collide with the builtin kinds."]}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-type-of-an-existing-kind",children:"Adding a New Type of an Existing Kind"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\"This is clearly a component, but it's of a type that doesn't quite fit with\nthe ones I've seen before.\""}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"We don\'t call our teams "team", can\'t we put "flock" as the group type?"'}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Some entity kinds have a ",(0,a.jsx)(t.code,{children:"type"})," field in its spec. This is where an organization\nare free to express the variety of entities within a kind. This field is\nexpected to follow some taxonomy that makes sense for yourself. The chosen value\nmay affect what operations and views are enabled in Backstage for that entity.\nInside Spotify our model has grown significantly over the years, and our\ncomponent types now include ML models, apps, data pipelines and many more."]}),"\n",(0,a.jsx)(t.p,{children:"It might be tempting to put software that doesn't fit into any of the existing\ntypes into an Other catch-all type. There are a few reasons why we advise\nagainst this; firstly, we have found that it is preferred to match the\nconceptual model that your engineers have when describing your software.\nSecondly, Backstage helps your engineers manage their software by integrating\nthe infrastructure tooling through plugins. Different plugins are used for\nmanaging different types of components."}),"\n",(0,a.jsxs)(t.p,{children:["For example, the\n",(0,a.jsx)(t.a,{href:"https://github.com/backstage/backstage/tree/master/plugins/lighthouse",children:"Lighthouse plugin"}),"\nonly makes sense for Websites. The more specific you can be in how you model\nyour software, the easier it is to provide plugins that are contextual."]}),"\n",(0,a.jsx)(t.p,{children:"Adding a new type takes relatively little effort and carries little risk. Any\ntype value is accepted by the catalog backend, but plugins may have to be\nupdated if you want particular behaviors attached to that new type."}),"\n",(0,a.jsx)(t.h2,{id:"changing-the-validation-rules-for-the-entity-envelope-or-metadata-fields",children:"Changing the Validation Rules for The Entity Envelope or Metadata Fields"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"We want to import our old catalog but the default set of allowed characters\nfor a metadata.name are too strict."'}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"I want to change the rules for annotations so that I\'m allowed to store any\ndata in annotation values, not just strings."'}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["After pieces of raw entity data have been read from a location, they are passed\nthrough a fixed number of so called ",(0,a.jsx)(t.code,{children:"Validators"}),", as part of the entity policy\ncheck step. They ensure that the types and syntax of the base envelope and\nmetadata make sense - in short, things that aren't entity-kind-specific. Some or\nall of these validators can be replaced when building the backend catalog using\nthe ",(0,a.jsx)(t.code,{children:"CatalogBuilder"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"The risk and impact of this type of extension varies, based on what it is that\nyou want to do. For example, extending the valid character set for kinds,\nnamespaces and names can be fairly harmless, with a few notable exceptions -\nthere is code that expects these to never ever contain a colon or slash, for\nexample, and introducing URL-unsafe characters risks breaking plugins that\naren't careful about encoding arguments. Supporting non-strings in annotations\nmay be possible but has not yet been tried out in the real world - there is\nlikely to be some level of plugin breakage that can be hard to predict."}),"\n",(0,a.jsx)(t.p,{children:"Before making this kind of extension, we recommend that you contact the\nBackstage maintainers or a support partner to discuss your use case."}),"\n",(0,a.jsx)(t.h2,{id:"changing-the-validation-rules-for-core-entity-fields",children:"Changing the Validation Rules for Core Entity Fields"}),"\n",(0,a.jsx)(t.p,{children:"Example intent:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\"I don't like that the owner is mandatory. I'd like it to be optional.\""}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["After reading and policy-checked entity data from a location, it is sent through\nthe processor chain looking for processors that implement the\n",(0,a.jsx)(t.code,{children:"validateEntityKind"})," step, to see that the data is of a known kind and abides by\nits schema. There is a builtin processor that implements this for all known core\nkinds and matches the data against their fixed validation schema. This processor\ncan be replaced when building the backend catalog using the ",(0,a.jsx)(t.code,{children:"CatalogBuilder"}),",\nwith a processor of your own that validates the data differently.\nThis replacement processor must have a name that matches the builtin processor, ",(0,a.jsx)(t.code,{children:"BuiltinKindsEntityProcessor"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["This type of extension is high risk, and may have high impact across the\necosystem depending on the type of change that is made. It is therefore not\nrecommended in normal cases. There will be a large number of plugins and\nprocessors - and even the core itself - that make assumptions about the shape of\nthe data and import the typescript data type from the ",(0,a.jsx)(t.code,{children:"@backstage/catalog-model"}),"\npackage."]}),"\n",(0,a.jsx)(t.h2,{id:"adding-new-fields-to-the-metadata-object",children:"Adding New Fields to the Metadata Object"}),"\n",(0,a.jsx)(t.p,{children:"Example intent:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"Our entities have this auxiliary property that I would like to express for\nseveral entity kinds and it doesn\'t really fit as a spec field."'}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The metadata object is currently left open for extension. Any unknown fields\nfound in the metadata will just be stored verbatim in the catalog. However we\nwant to caution against extending the metadata excessively. Firstly, you run the\nrisk of colliding with future extensions to the model. Secondly, it is common\nthat this type of extension lives more comfortably elsewhere - primarily in the\nmetadata labels or annotations, but sometimes you even may want to make a new\ncomponent type or similar instead."}),"\n",(0,a.jsx)(t.p,{children:"There are some situations where metadata can be the right place. If you feel\nthat you have run into such a case and that it would apply to others, do feel\nfree to contact the Backstage maintainers or a support partner to discuss your\nuse case. Maybe we can extend the core model to benefit both you and others."}),"\n",(0,a.jsx)(t.h2,{id:"adding-new-fields-to-the-spec-object-of-an-existing-kind",children:"Adding New Fields to the Spec Object of an Existing Kind"}),"\n",(0,a.jsx)(t.p,{children:"Example intent:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"The builtin Component kind is fine but we want to add an additional field to\nthe spec for describing whether it\'s in prod or staging."'}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["A kind's schema validation typically doesn't forbid \"unknown\" fields in an\nentity ",(0,a.jsx)(t.code,{children:"spec"}),", and the catalog will happily store whatever is in it. So doing\nthis will usually work from the catalog's point of view."]}),"\n",(0,a.jsx)(t.p,{children:"Adding fields like this is subject to the same risks as mentioned about metadata\nextensions above. Firstly, you run the risk of colliding with future extensions\nto the model. Secondly, it is common that this type of extension lives more\ncomfortably elsewhere - primarily in the metadata labels or annotations, but\nsometimes you even may want to make a new component type or similar instead."}),"\n",(0,a.jsx)(t.p,{children:"There are some situations where the spec can be the right place. If you feel\nthat you have run into such a case and that it would apply to others, do feel\nfree to contact the Backstage maintainers or a support partner to discuss your\nuse case. Maybe we can extend the core model to benefit both you and others."}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-annotation",children:"Adding a New Annotation"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"Our custom made build system has the concept of a named pipeline-set, and we\nwant to associate individual components with their corresponding pipeline-sets\nso we can show their build status."'}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"\"We have an alerting system that automatically monitors service health, and\nthere's this integration key that binds the service to an alerts pool. We want\nto be able to show the ongoing alerts for our services in Backstage so it'd be\nnice to attach that integration key to the entity somehow.\""}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Annotations are mainly intended to be consumed by plugins, for feature detection\nor linking into external systems. Sometimes they are added by humans, but often\nthey are automatically generated at ingestion time by processors. There is a set\nof ",(0,a.jsx)(t.a,{href:"/docs/features/software-catalog/well-known-annotations",children:"well-known annotations"}),", but you are free to add\nadditional ones. This carries no risk or impact to other systems as long as you\nabide by the following naming rules."]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"backstage.io"})," annotation prefix is reserved for use by the Backstage\nmaintainers. Reach out to us if you feel that you would like to make an\naddition to that prefix."]}),"\n",(0,a.jsxs)(t.li,{children:["Annotations that pertain to a well known third party system should ideally be\nprefixed with a domain, in a way that makes sense to a reader and connects it\nclearly to the system (or the maker of the system). For example, you might use\na ",(0,a.jsx)(t.code,{children:"pagerduty.com"})," prefix for pagerduty related annotations, but maybe not\n",(0,a.jsx)(t.code,{children:"ldap.com"})," for LDAP annotations since it's not directly affiliated with or\nowned by an LDAP foundation/company/similar."]}),"\n",(0,a.jsx)(t.li,{children:"Annotations that have no prefix at all, are considered local to your Backstage\ninstance and can be used freely as such, but you should not make use of them\noutside of your organization. For example, if you were to open source a plugin\nthat generates or consumes annotations, then those annotations must be\nproperly prefixed with your company domain or a domain that pertains to the\nannotation at hand."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-label",children:"Adding a New Label"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"Our process reaping system wants to periodically scrape for components that\nhave a certain property."'}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"It\'d be nice if our service owners could just tag their components somehow to\nlet the CD system know to automatically generate SRV records or not for that\nservice."'}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Labels are mainly intended to be used for filtering of entities, by external\nsystems that want to find entities that have some certain property. This is\nsometimes used for feature detection / selection. An example could be to add a\nlabel ",(0,a.jsx)(t.code,{children:'deployments.my-company.net/register-srv: "true"'}),"."]}),"\n",(0,a.jsx)(t.p,{children:"At the time of writing this, the use of labels is very limited and we are still\nsettling together with the community on how to best use them. If you feel that\nyour use case fits the labels best, we would appreciate if you let the Backstage\nmaintainers know."}),"\n",(0,a.jsx)(t.p,{children:"You are free to add labels. This carries no risk or impact to other systems as\nlong as you abide by the following naming rules."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"backstage.io"})," label prefix is reserved for use by the Backstage\nmaintainers. Reach out to us if you feel that you would like to make an\naddition to that prefix."]}),"\n",(0,a.jsxs)(t.li,{children:["Labels that pertain to a well known third party system should ideally be\nprefixed with a domain, in a way that makes sense to a reader and connects it\nclearly to the system (or the maker of the system). For example, you might use\na ",(0,a.jsx)(t.code,{children:"pagerduty.com"})," prefix for pagerduty related labels, but maybe not\n",(0,a.jsx)(t.code,{children:"ldap.com"})," for LDAP labels since it's not directly affiliated with or owned by\nan LDAP foundation/company/similar."]}),"\n",(0,a.jsx)(t.li,{children:"Labels that have no prefix at all, are considered local to your Backstage\ninstance and can be used freely as such, but you should not make use of them\noutside of your organization. For example, if you were to open source a plugin\nthat generates or consumes labels, then those labels must be properly prefixed\nwith your company domain or a domain that pertains to the label at hand."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-relation-type",children:"Adding a New Relation Type"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"We have this concept of service maintainership, separate from ownership, that\nwe would like to make relations to individual users for."'}),"\n"]}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"We feel that we want to explicitly model the team-to-global-department\nmapping as a relation, because it is core to our org setup and we frequently\nquery for it."'}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["Any processor can emit relations for entities as they are being processed, and\nnew processors can be added when building the backend catalog using the\n",(0,a.jsx)(t.code,{children:"CatalogBuilder"}),". They can emit relations based on the entity data itself, or\nbased on information gathered from elsewhere. Relations are directed and go from\na source entity to a target entity. They are also tied to the entity that\noriginated them - the one that was subject to processing when the relation was\nemitted. Relations may be dangling (referencing something that does not actually\nexist by that name in the catalog), and callers need to be aware of that."]}),"\n",(0,a.jsxs)(t.p,{children:["There is a set of ",(0,a.jsx)(t.a,{href:"/docs/features/software-catalog/well-known-relations",children:"well-known relations"}),", but you are\nfree to emit your own as well. You cannot change the fact that they are directed\nand have a source and target that have to be an\n",(0,a.jsx)(t.a,{href:"/docs/features/software-catalog/references",children:"entity reference"}),", but you can invent your own types. You do not\nhave to make any changes to the catalog backend in order to accept new relation\ntypes."]}),"\n",(0,a.jsxs)(t.p,{children:["At the time of writing this, we do not have any namespacing/prefixing scheme for\nrelation types. The type is also not validated to contain only some particular\nset of characters. Until rules for this are settled, you should stick to using\nonly letters, dashes and digits, and to avoid collisions with future core\nrelation types, you may want to prefix the type somehow. For example:\n",(0,a.jsx)(t.code,{children:"myCompany-maintainerOf"})," + ",(0,a.jsx)(t.code,{children:"myCompany-maintainedBy"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"If you have a suggestion for a relation type to be elevated to the core\noffering, reach out to the Backstage maintainers or a support partner."}),"\n",(0,a.jsx)(t.h2,{id:"using-a-well-known-relation-type-for-a-new-purpose",children:"Using a Well-Known Relation Type for a New Purpose"}),"\n",(0,a.jsx)(t.p,{children:"Example intents:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"The ownerOf/ownedBy relation types sound like a good fit for expressing how\nusers are technical owners of our company specific ServiceAccount kind, and we\nwant to reuse those relation types for that."'}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["At the time of writing, this is uncharted territory. If the documented use of a\nrelation states that one end of the relation commonly is a User or a Group, for\nexample, then consumers are likely to have conditional statements on the form\n",(0,a.jsx)(t.code,{children:"if (x.kind === 'User') {} else {}"}),", which get confused when an unexpected kind\nappears."]}),"\n",(0,a.jsx)(t.p,{children:"If you want to extend the use of an established relation type in a way that has\nan effect outside of your organization, reach out to the Backstage maintainers\nor a support partner to discuss risk/impact. It may even be that one end of the\nrelation could be considered for addition to the core."}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-status-field",children:"Adding a New Status field"}),"\n",(0,a.jsx)(t.p,{children:"Example intent:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["\"We would like to convey entity statuses through the catalog in a generic way,\nas an integration layer. Our monitoring and alerting system has a plugin with\nBackstage, and it would be useful if the entity's status field contained the\ncurrent alert state close to the actual entity data for anyone to consume. We\nfind the ",(0,a.jsx)(t.code,{children:"status.items"})," semantics a poor fit, so we would prefer to make our\nown custom field under ",(0,a.jsx)(t.code,{children:"status"}),' for these purposes."']}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["We have not yet ventured to define any generic semantics for the ",(0,a.jsx)(t.code,{children:"status"}),"\nobject. We recommend sticking with the ",(0,a.jsx)(t.code,{children:"status.items"})," mechanism where possible\n(see below), since third party consumers will not be able to consume your status\ninformation otherwise. Please reach out to the maintainers on Discord or by\nmaking a GitHub issue describing your use case if you are interested in this\ntopic."]}),"\n",(0,a.jsx)(t.h2,{id:"adding-a-new-status-item-type",children:"Adding a New Status Item Type"}),"\n",(0,a.jsx)(t.p,{children:"Example intent:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:['"The semantics of the entity ',(0,a.jsx)(t.code,{children:"status.items"}),' field are fine for our needs, but\nwe want to contribute our own type of status into that array instead of the\ncatalog specific one."']}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"This is a simple, low risk way of adding your own status information to\nentities. Consumers will be able to easily track and display the status together\nwith other types / sources."}),"\n",(0,a.jsxs)(t.p,{children:["We recommend that any status type that are not strictly private within the\norganization be namespaced to avoid collisions. Statuses emitted by Backstage\ncore processes will for example be prefixed with ",(0,a.jsx)(t.code,{children:"backstage.io/"}),", your\norganization may prefix with ",(0,a.jsx)(t.code,{children:"my-org.net/"}),", and ",(0,a.jsx)(t.code,{children:"pagerduty.com/active-alerts"}),"\ncould be a sensible complete status item type for that particular external\nsystem."]}),"\n",(0,a.jsxs)(t.p,{children:["The mechanics for how to emit custom statuses is not in place yet, so if this is\nof interest to you, you might consider contacting the maintainers on Discord or\nmy making a GitHub issue describing your use case.\n",(0,a.jsx)(t.a,{href:"https://github.com/backstage/backstage/issues/2292",children:"This issue"})," also contains\nmore context."]}),"\n",(0,a.jsx)(t.h2,{id:"referencing-different-environments-with-the-model",children:"Referencing different environments with the model"}),"\n",(0,a.jsx)(t.p,{children:"Example intent:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:['"I have multiple versions of my API deployed in different environments so I\nwant to have ',(0,a.jsx)(t.code,{children:"mytool-dev"})," and ",(0,a.jsx)(t.code,{children:"mytool-prod"}),' as different entities."']}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["While it's possible to have different versions of the same thing represented as\nseparate entities, it's something we generally recommend against. We believe\nthat a developer should be able to just find for example one ",(0,a.jsx)(t.code,{children:"Component"}),"\nrepresenting a service, and to be able to see the different code versions that\nare deployed throughout your stack within its view. This reasoning works\nsimilarly for other kinds as well, such as ",(0,a.jsx)(t.code,{children:"API"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["That being said - sometimes the differences between versions are so large, that\nthey represent what is for all intents and purposes an entirely new entity as\nseen from the consumer's point of view. This can happen for example for\ndifferent ",(0,a.jsx)(t.em,{children:"significant"})," major versions of an API, and in particular if the two\nmajor versions coexist in the ecosystem for some time. In those cases, it can be\nmotivated to have one ",(0,a.jsx)(t.code,{children:"my-api-v2"})," and one ",(0,a.jsx)(t.code,{children:"my-api-v3"})," named entity. This matches\nthe end user's expectations when searching for the API, and matches the desire\nto maybe have separate documentation for the two and similar. But use this\nsparingly - only do it if the extra modelling burden is outweighed by any\npotential better clarity for users."]}),"\n",(0,a.jsx)(t.p,{children:"When writing your custom plugins, we encourage designing them such that they can\nshow all the different variations through environments etc under one canonical\nreference to your software in the catalog. For example for a continuous\ndeployment plugin, a user is likely to be greatly helped by being able to see\nthe entity's versions deployed in all different environments next to each other\nin one view. That is also where they might be offered the ability to promote\nfrom one environment to the other, do rollbacks, see their relative performance\nmetrics, and similar. This coherency and collection of tooling in one place is\nwhere something like Backstage can offer the most value and effectiveness of\nuse. Splitting your entities apart into small islands makes this harder."}),"\n",(0,a.jsx)(t.h2,{id:"implementing-custom-model-extensions",children:"Implementing custom model extensions"}),"\n",(0,a.jsx)(t.p,{children:"This section walks you through the steps involved extending the catalog model\nwith a new Entity type."}),"\n",(0,a.jsx)(t.h3,{id:"creating-a-custom-entity-definition",children:"Creating a custom entity definition"}),"\n",(0,a.jsx)(t.p,{children:"The first step of introducing a custom entity is to define what shape and schema\nit has. We do this using a TypeScript type, as well as a JSONSchema schema."}),"\n",(0,a.jsxs)(t.p,{children:["Most of the time you will want to have at least the TypeScript type of your\nextension available in both frontend and backend code, which means you likely\nwant to have an isomorphic package that houses these types. Within the Backstage\nmain repo the package naming pattern of ",(0,a.jsx)(t.code,{children:"<plugin>-common"})," is used for isomorphic\npackages, and you may choose to adopt this pattern as well."]}),"\n",(0,a.jsxs)(t.p,{children:["You can generate an isomorphic plugin package by running:",(0,a.jsx)(t.code,{children:"yarn new --select plugin-common"}),"\nor you can run ",(0,a.jsx)(t.code,{children:"yarn new"}),' and then select "plugin-common" from the list of options']}),"\n",(0,a.jsxs)(t.p,{children:["There's at this point no existing templates for generating isomorphic plugins\nusing the ",(0,a.jsx)(t.code,{children:"@backstage/cli"}),". Perhaps the simplest wat to get started right now is\nto copy the contents of one of the existing packages in the main repository,\nsuch as ",(0,a.jsx)(t.code,{children:"plugins/scaffolder-common"}),", and rename the folder and file contents to\nthe desired name. This example uses ",(0,a.jsx)(t.em,{children:"foobar"})," as the plugin name so the plugin\nwill be named ",(0,a.jsx)(t.em,{children:"foobar-common"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Once you have a common package in place you can start adding your own entity\ndefinitions. For the exact details on how to do that we defer to getting\ninspired by the existing\n",(0,a.jsx)(t.a,{href:"https://github.com/backstage/backstage/tree/master/plugins/scaffolder-common/src/index.ts",children:"scaffolder-common"}),"\npackage. But in short you will need to declare a TypeScript type and a\nJSONSchema for the new entity kind."]}),"\n",(0,a.jsx)(t.h3,{id:"building-a-custom-processor-for-the-entity",children:"Building a custom processor for the entity"}),"\n",(0,a.jsxs)(t.p,{children:["The next step is to create a custom processor for your new entity kind. This\nwill be used within the catalog to make sure that it's able to ingest and\nvalidate entities of our new kind. Just like with the definition package, you\ncan find inspiration in for example the existing\n",(0,a.jsx)(t.a,{href:"https://github.com/backstage/backstage/tree/master/plugins/catalog-backend-module-scaffolder-entity-model/src/processor/ScaffolderEntitiesProcessor.ts",children:"ScaffolderEntitiesProcessor"}),".\nWe also provide a high-level example of what a catalog process for a custom\nentity might look like:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"import { CatalogProcessor, CatalogProcessorEmit, processingResult } from '@backstage/plugin-catalog-node';\nimport { LocationSpec } from '@backstage/plugin-catalog-common'\nimport { Entity, entityKindSchemaValidator } from '@backstage/catalog-model';\n\n// For an example of the JSONSchema format and how to use $ref markers to the\n// base definitions, see:\n// https://github.com/backstage/backstage/tree/master/packages/catalog-model/src/schema/kinds/Component.v1alpha1.schema.json\nimport { foobarEntityV1alpha1Schema } from '@internal/catalog-model';\n\nexport class FoobarEntitiesProcessor implements CatalogProcessor {\n  // You often end up wanting to support multiple versions of your kind as you\n  // iterate on the definition, so we keep each version inside this array as a\n  // convenient pattern.\n  private readonly validators = [\n    // This is where we use the JSONSchema that we export from our isomorphic\n    // package\n    entityKindSchemaValidator(foobarEntityV1alpha1Schema),\n  ];\n\n  // Return processor name\n  getProcessorName(): string {\n    return 'FoobarEntitiesProcessor'\n  }\n\n  // validateEntityKind is responsible for signaling to the catalog processing\n  // engine that this entity is valid and should therefore be submitted for\n  // further processing.\n  async validateEntityKind(entity: Entity): Promise<boolean> {\n    for (const validator of this.validators) {\n      // If the validator throws an exception, the entity will be marked as\n      // invalid.\n      if (validator(entity)) {\n        return true;\n      }\n    }\n\n    // Returning false signals that we don't know what this is, passing the\n    // responsibility to other processors to try to validate it instead.\n    return false;\n  }\n\n  async postProcessEntity(\n    entity: Entity,\n    _location: LocationSpec,\n    emit: CatalogProcessorEmit,\n  ): Promise<Entity> {\n    if (\n      entity.apiVersion === 'example.com/v1alpha1' &&\n      entity.kind === 'Foobar'\n    ) {\n      const foobarEntity = entity as FoobarEntityV1alpha1;\n\n      // Typically you will want to emit any relations associated with the\n      // entity here.\n      emit(processingResult.relation({ ... }))\n    }\n\n    return entity;\n  }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Once the processor is created it can be wired up to the catalog via the\n",(0,a.jsx)(t.code,{children:"CatalogBuilder"})," in ",(0,a.jsx)(t.code,{children:"packages/backend/src/plugins/catalog.ts"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",metastring:'title="packages/backend/src/plugins/catalog.ts"',children:"/* highlight-add-next-line */\nimport { FoobarEntitiesProcessor } from '@internal/plugin-foobar-backend';\n\nexport default async function createPlugin(\n  env: PluginEnvironment,\n): Promise<Router> {\n  const builder = await CatalogBuilder.create(env);\n  /* highlight-add-next-line */\n  builder.addProcessor(new FoobarEntitiesProcessor());\n  const { processingEngine, router } = await builder.build();\n  // ..\n}\n"})})]})}const h=function(e={}){const{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?(0,a.jsx)(t,Object.assign({},e,{children:(0,a.jsx)(d,e)})):d(e)}},371426:(e,t,n)=>{var a=n(827378),o=Symbol.for("react.element"),i=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(e,t,n){var a,i={},c=null,d=null;for(a in void 0!==n&&(c=""+n),void 0!==t.key&&(c=""+t.key),void 0!==t.ref&&(d=t.ref),t)s.call(t,a)&&!l.hasOwnProperty(a)&&(i[a]=t[a]);if(e&&e.defaultProps)for(a in t=e.defaultProps)void 0===i[a]&&(i[a]=t[a]);return{$$typeof:o,type:e,key:c,ref:d,props:i,_owner:r.current}}t.Fragment=i,t.jsx=c,t.jsxs=c},541535:(e,t)=>{var n=Symbol.for("react.element"),a=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),r=Symbol.for("react.provider"),l=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),d=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),u=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,y={};function g(e,t,n){this.props=e,this.context=t,this.refs=y,this.updater=n||f}function w(){}function b(e,t,n){this.props=e,this.context=t,this.refs=y,this.updater=n||f}g.prototype.isReactComponent={},g.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},g.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},w.prototype=g.prototype;var x=b.prototype=new w;x.constructor=b,m(x,g.prototype),x.isPureReactComponent=!0;var k=Array.isArray,v=Object.prototype.hasOwnProperty,j={current:null},E={key:!0,ref:!0,__self:!0,__source:!0};function T(e,t,a){var o,i={},s=null,r=null;if(null!=t)for(o in void 0!==t.ref&&(r=t.ref),void 0!==t.key&&(s=""+t.key),t)v.call(t,o)&&!E.hasOwnProperty(o)&&(i[o]=t[o]);var l=arguments.length-2;if(1===l)i.children=a;else if(1<l){for(var c=Array(l),d=0;d<l;d++)c[d]=arguments[d+2];i.children=c}if(e&&e.defaultProps)for(o in l=e.defaultProps)void 0===i[o]&&(i[o]=l[o]);return{$$typeof:n,type:e,key:s,ref:r,props:i,_owner:j.current}}function S(e){return"object"==typeof e&&null!==e&&e.$$typeof===n}var _=/\/+/g;function A(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function C(e,t,o,i,s){var r=typeof e;"undefined"!==r&&"boolean"!==r||(e=null);var l=!1;if(null===e)l=!0;else switch(r){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case a:l=!0}}if(l)return s=s(l=e),e=""===i?"."+A(l,0):i,k(s)?(o="",null!=e&&(o=e.replace(_,"$&/")+"/"),C(s,t,o,"",(function(e){return e}))):null!=s&&(S(s)&&(s=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(s,o+(!s.key||l&&l.key===s.key?"":(""+s.key).replace(_,"$&/")+"/")+e)),t.push(s)),1;if(l=0,i=""===i?".":i+":",k(e))for(var c=0;c<e.length;c++){var d=i+A(r=e[c],c);l+=C(r,t,o,d,s)}else if(d=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"==typeof d)for(e=d.call(e),c=0;!(r=e.next()).done;)l+=C(r=r.value,t,o,d=i+A(r,c++),s);else if("object"===r)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function P(e,t,n){if(null==e)return e;var a=[],o=0;return C(e,a,"","",(function(e){return t.call(n,e,o++)})),a}function I(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var R={current:null},B={transition:null},O={ReactCurrentDispatcher:R,ReactCurrentBatchConfig:B,ReactCurrentOwner:j};t.Children={map:P,forEach:function(e,t,n){P(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return P(e,(function(){t++})),t},toArray:function(e){return P(e,(function(e){return e}))||[]},only:function(e){if(!S(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=g,t.Fragment=o,t.Profiler=s,t.PureComponent=b,t.StrictMode=i,t.Suspense=d,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=O,t.cloneElement=function(e,t,a){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var o=m({},e.props),i=e.key,s=e.ref,r=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,r=j.current),void 0!==t.key&&(i=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(c in t)v.call(t,c)&&!E.hasOwnProperty(c)&&(o[c]=void 0===t[c]&&void 0!==l?l[c]:t[c])}var c=arguments.length-2;if(1===c)o.children=a;else if(1<c){l=Array(c);for(var d=0;d<c;d++)l[d]=arguments[d+2];o.children=l}return{$$typeof:n,type:e.type,key:i,ref:s,props:o,_owner:r}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:r,_context:e},e.Consumer=e},t.createElement=T,t.createFactory=function(e){var t=T.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:c,render:e}},t.isValidElement=S,t.lazy=function(e){return{$$typeof:u,_payload:{_status:-1,_result:e},_init:I}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=B.transition;B.transition={};try{e()}finally{B.transition=t}},t.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},t.useCallback=function(e,t){return R.current.useCallback(e,t)},t.useContext=function(e){return R.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return R.current.useDeferredValue(e)},t.useEffect=function(e,t){return R.current.useEffect(e,t)},t.useId=function(){return R.current.useId()},t.useImperativeHandle=function(e,t,n){return R.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return R.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return R.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return R.current.useMemo(e,t)},t.useReducer=function(e,t,n){return R.current.useReducer(e,t,n)},t.useRef=function(e){return R.current.useRef(e)},t.useState=function(e){return R.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return R.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return R.current.useTransition()},t.version="18.2.0"},827378:(e,t,n)=>{e.exports=n(541535)},824246:(e,t,n)=>{e.exports=n(371426)},511151:(e,t,n)=>{n.d(t,{Zo:()=>r,ah:()=>i});var a=n(667294);const o=a.createContext({});function i(e){const t=a.useContext(o);return a.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const s={};function r({components:e,children:t,disableParentContext:n}){let r;return r=n?"function"==typeof e?e({}):e||s:i(e),a.createElement(o.Provider,{value:r},t)}}}]);