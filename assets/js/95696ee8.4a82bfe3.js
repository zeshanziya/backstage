/*! For license information please see 95696ee8.4a82bfe3.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[238739],{726289:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var r=n(824246),i=n(511151);const o={id:"migrating",title:"Migrating your Backend Plugin to the New Backend System",sidebar_label:"Migration Guide",description:"How to migrate existing backend plugins to the new backend system"},s=void 0,a={id:"backend-system/building-plugins-and-modules/migrating",title:"Migrating your Backend Plugin to the New Backend System",description:"How to migrate existing backend plugins to the new backend system",source:"@site/../docs/backend-system/building-plugins-and-modules/08-migrating.md",sourceDirName:"backend-system/building-plugins-and-modules",slug:"/backend-system/building-plugins-and-modules/migrating",permalink:"/docs/backend-system/building-plugins-and-modules/migrating",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/backend-system/building-plugins-and-modules/08-migrating.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{id:"migrating",title:"Migrating your Backend Plugin to the New Backend System",sidebar_label:"Migration Guide",description:"How to migrate existing backend plugins to the new backend system"},sidebar:"docs",previous:{title:"Testing",permalink:"/docs/backend-system/building-plugins-and-modules/testing"},next:{title:"Overview",permalink:"/docs/backend-system/core-services/index"}},u={},c=[];function l(e){const t=Object.assign({p:"p",code:"code",pre:"pre",a:"a"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Migrating an existing backend plugin to the new backend system is fairly straightforward. The process is similar across the majority of plugins which just return a ",(0,r.jsx)(t.code,{children:"Router"})," that is then wired up in the ",(0,r.jsx)(t.code,{children:"index.ts"})," file of your backend. The primary thing that we need to do is to make sure that the dependencies that are required by the plugin are available, and then registering the router with the HTTP router service."]}),"\n",(0,r.jsx)(t.p,{children:"Let's look at an example of migrating the Kubernetes backend plugin. In the existing (old) system, the kubernetes backend is structured like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// @backstage/plugin-kubernetes-backend/src/service/router.ts\n\nimport { KubernetesBuilder } from './KubernetesBuilder';\nexport interface RouterOptions {\n  logger: Logger;\n  config: Config;\n  catalogApi: CatalogApi;\n  clusterSupplier?: KubernetesClustersSupplier;\n  discovery: PluginEndpointDiscovery;\n}\n\nexport async function createRouter(\n  options: RouterOptions,\n): Promise<express.Router> {\n  const { router } = await KubernetesBuilder.createBuilder(options)\n    .setClusterSupplier(options.clusterSupplier)\n    .build();\n  return router;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["We can re-use the ",(0,r.jsx)(t.code,{children:"router"})," created by the ",(0,r.jsx)(t.code,{children:"KubernetesBuilder"})," in the new backend system. We only need to make sure that the dependencies specified in ",(0,r.jsx)(t.code,{children:"RouterOptions"})," above are available. All of them are part of the ",(0,r.jsx)(t.code,{children:"coreServices"})," which makes migration easy."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import {\n  coreServices,\n  createBackendPlugin,\n} from '@backstage/backend-plugin-api';\nimport { catalogServiceRef } from '@backstage/plugin-catalog-node';\nimport { Router } from 'express';\nimport { KubernetesBuilder } from './KubernetesBuilder';\n\nexport const kubernetesPlugin = createBackendPlugin({\n  pluginId: 'kubernetes',\n  register(env) {\n    env.registerInit({\n      deps: {\n        logger: coreServices.logger,\n        config: coreServices.rootConfig,\n        catalogApi: catalogServiceRef,\n        discovery: coreServices.discovery,\n        // The http router service is used to register the router created by the KubernetesBuilder.\n        http: coreServices.httpRouter,\n      },\n      async init({ config, logger, catalogApi, discovery, http }) {\n        const { router } = await KubernetesBuilder.createBuilder({\n          config,\n          logger,\n          catalogApi,\n          discovery,\n        }).build();\n\n        // We register the router with the http service.\n        http.use(router);\n      },\n    });\n  },\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Lastly, make sure you re-export the plugin instance as the default export of your package in ",(0,r.jsx)(t.code,{children:"src/index.ts"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"export { kubernetesPlugin as default } from './plugin.ts';\n"})}),"\n",(0,r.jsx)(t.p,{children:"Done! Users of this plugin are now able to import your plugin package and register it in their backend using"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"// packages/backend/src/index.ts\nbackend.add(import('@backstage/plugin-kubernetes-backend'));\n"})}),"\n",(0,r.jsxs)(t.p,{children:["There's one thing missing that those sharp eyed readers might have noticed: the ",(0,r.jsx)(t.code,{children:"clusterSupplier"})," option is missing from the original plugin. Let's add it and discuss the alternatives."]}),"\n",(0,r.jsxs)(t.p,{children:["One alternative is to make it possible to build the cluster supplier using static configuration. It could for example be that there is a selection of built-in implementations to choose from, or that the logic for how the ",(0,r.jsx)(t.code,{children:"ClusterSupplier"})," is supposed to function is all determined by configuration, or a combination of the two. Using static configuration for customization is always the preferred option whenever it's possible. In this case, we could for example imagine that we would be able to configure our cluster supplier like this:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"/* omitted imports but they remain the same as above */\n\nconst kubernetesPlugin = createBackendPlugin({\n  pluginId: 'kubernetes',\n  register(env) {\n    env.registerInit({\n      deps: {\n        /* omitted dependencies but they remain the same as above */\n      },\n      async init({ config, logger, catalogApi, discovery, http }) {\n        // Note that in a real implementation this would be done by the `KubernetesBuilder` instead,\n        // but here we've extracted it into a separate call to highlight the example.\n        const configuredClusterSupplier = readClusterSupplierFromConfig(config);\n\n        const { router } = await KubernetesBuilder.createBuilder({\n          config,\n          logger,\n          catalogApi,\n          discovery,\n        })\n          .setClusterSupplier(configuredClusterSupplier)\n          .build();\n        http.use(router);\n      },\n    });\n  },\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["There are however many types of customizations that are not possible to do with static configuration. In this case we want integrators to be able to create arbitrary implementations of the ",(0,r.jsx)(t.code,{children:"ClusterSupplier"})," interface, which in the end requires an implementation through code. This is where the new backend system's ",(0,r.jsx)(t.a,{href:"/docs/backend-system/architecture/extension-points",children:"extension points"})," come in handy."]}),"\n",(0,r.jsxs)(t.p,{children:["The new ",(0,r.jsx)(t.a,{href:"/docs/backend-system/architecture/extension-points",children:"extension points"})," API allows ",(0,r.jsx)(t.a,{href:"/docs/backend-system/architecture/modules",children:"modules"})," to add functionality into the backend plugin itself, in this case an additional ",(0,r.jsx)(t.code,{children:"ClusterSupplier"}),". Let's look at how we could add support for installing custom suppliers using an extension point. This will allow integrators to build their own internal module with a custom ",(0,r.jsx)(t.code,{children:"ClusterSupplier"})," implementation."]}),"\n",(0,r.jsxs)(t.p,{children:["First we'll go ahead and create a ",(0,r.jsx)(t.code,{children:"@backstage/plugin-kubernetes-node"})," package where we can define our extension point. A separate package is used to avoid direct dependencies on the plugin package itself. With the new package created, we define the extension point like this:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { createExtensionPoint } from '@backstage/backend-plugin-api';\n\nexport interface KubernetesClusterSupplierExtensionPoint {\n  setClusterSupplier(supplier: KubernetesClustersSupplier): void;\n}\n\n/**\n * An extension point that allows other plugins to set the cluster supplier.\n */\nexport const kubernetesClustersSupplierExtensionPoint =\n  createExtensionPoint<KubernetesClusterSupplierExtensionPoint>({\n    id: 'kubernetes.cluster-supplier',\n  });\n"})}),"\n",(0,r.jsxs)(t.p,{children:["For more information on how to design extension points, see the ",(0,r.jsx)(t.a,{href:"/docs/backend-system/architecture/extension-points#extension-point-design",children:"extension points"})," documentation."]}),"\n",(0,r.jsx)(t.p,{children:"Next we'll need to add support for this extension point to the Kubernetes backend plugin itself:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"/* omitted other imports but they remain the same as above */\nimport { kubernetesClustersSupplierExtensionPoint } from '@backstage/plugin-kubernetes-node';\n\nexport const kubernetesPlugin = createBackendPlugin({\n  pluginId: 'kubernetes',\n  register(env) {\n    let clusterSupplier: KubernetesClustersSupplier | undefined = undefined;\n\n    // We register the extension point with the backend, which allows modules to\n    // register their own ClusterSupplier.\n    env.registerExtensionPoint(kubernetesClustersSupplierExtensionPoint, {\n      setClusterSupplier(supplier) {\n        if (clusterSupplier) {\n          throw new Error('ClusterSupplier may only be set once');\n        }\n        clusterSupplier = supplier;\n      },\n    });\n\n    env.registerInit({\n      deps: {\n        /* omitted dependencies but they remain the same as above */\n      },\n      async init({ config, logger, catalogApi, discovery, http }) {\n        const { router } = await KubernetesBuilder.createBuilder({\n          config,\n          logger,\n          catalogApi,\n          discovery,\n        })\n          .setClusterSupplier(clusterSupplier)\n          .build();\n        http.use(router);\n      },\n    });\n  },\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["And that's it! Modules can now be built that add clusters into to the kubernetes backend plugin, here's an example of a module that adds a ",(0,r.jsx)(t.code,{children:"GoogleContainerEngineSupplier"})," to the kubernetes backend:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"import { kubernetesClustersSupplierExtensionPoint } from '@backstage/plugin-kubernetes-node';\n\n// This is a custom implementation of the ClusterSupplier interface.\nimport { GoogleContainerEngineSupplier } from './GoogleContainerEngineSupplier';\n\nexport default createBackendModule({\n  pluginId: 'kubernetes',\n  moduleId: 'gke-supplier',\n  register(env) {\n    env.registerInit({\n      deps: {\n        supplier: kubernetesClustersSupplierExtensionPoint,\n      },\n      async init({ supplier }) {\n        supplier.setClusterSupplier(new GoogleContainerEngineSupplier());\n      },\n    });\n  },\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"The above module can then be installed by the integrator alongside the kubernetes backend plugin:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"backend.add(import('@backstage/plugin-kubernetes-backend'));\nbackend.add(import('@internal/gke-cluster-supplier'));\n"})})]})}const p=function(e={}){const{wrapper:t}=Object.assign({},(0,i.ah)(),e.components);return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(l,e)})):l(e)}},371426:(e,t,n)=>{var r=n(827378),i=Symbol.for("react.element"),o=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,a=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,u={key:!0,ref:!0,__self:!0,__source:!0};function c(e,t,n){var r,o={},c=null,l=null;for(r in void 0!==n&&(c=""+n),void 0!==t.key&&(c=""+t.key),void 0!==t.ref&&(l=t.ref),t)s.call(t,r)&&!u.hasOwnProperty(r)&&(o[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===o[r]&&(o[r]=t[r]);return{$$typeof:i,type:e,key:c,ref:l,props:o,_owner:a.current}}t.Fragment=o,t.jsx=c,t.jsxs=c},541535:(e,t)=>{var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),i=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),u=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),p=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),f=Symbol.iterator;var h={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function b(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||h}function y(){}function k(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||h}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},y.prototype=b.prototype;var x=k.prototype=new y;x.constructor=k,g(x,b.prototype),x.isPureReactComponent=!0;var v=Array.isArray,w=Object.prototype.hasOwnProperty,S={current:null},j={key:!0,ref:!0,__self:!0,__source:!0};function _(e,t,r){var i,o={},s=null,a=null;if(null!=t)for(i in void 0!==t.ref&&(a=t.ref),void 0!==t.key&&(s=""+t.key),t)w.call(t,i)&&!j.hasOwnProperty(i)&&(o[i]=t[i]);var u=arguments.length-2;if(1===u)o.children=r;else if(1<u){for(var c=Array(u),l=0;l<u;l++)c[l]=arguments[l+2];o.children=c}if(e&&e.defaultProps)for(i in u=e.defaultProps)void 0===o[i]&&(o[i]=u[i]);return{$$typeof:n,type:e,key:s,ref:a,props:o,_owner:S.current}}function C(e){return"object"==typeof e&&null!==e&&e.$$typeof===n}var E=/\/+/g;function P(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function R(e,t,i,o,s){var a=typeof e;"undefined"!==a&&"boolean"!==a||(e=null);var u=!1;if(null===e)u=!0;else switch(a){case"string":case"number":u=!0;break;case"object":switch(e.$$typeof){case n:case r:u=!0}}if(u)return s=s(u=e),e=""===o?"."+P(u,0):o,v(s)?(i="",null!=e&&(i=e.replace(E,"$&/")+"/"),R(s,t,i,"",(function(e){return e}))):null!=s&&(C(s)&&(s=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(s,i+(!s.key||u&&u.key===s.key?"":(""+s.key).replace(E,"$&/")+"/")+e)),t.push(s)),1;if(u=0,o=""===o?".":o+":",v(e))for(var c=0;c<e.length;c++){var l=o+P(a=e[c],c);u+=R(a,t,i,l,s)}else if(l=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=f&&e[f]||e["@@iterator"])?e:null}(e),"function"==typeof l)for(e=l.call(e),c=0;!(a=e.next()).done;)u+=R(a=a.value,t,i,l=o+P(a,c++),s);else if("object"===a)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return u}function B(e,t,n){if(null==e)return e;var r=[],i=0;return R(e,r,"","",(function(e){return t.call(n,e,i++)})),r}function O(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var I={current:null},$={transition:null},T={ReactCurrentDispatcher:I,ReactCurrentBatchConfig:$,ReactCurrentOwner:S};t.Children={map:B,forEach:function(e,t,n){B(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return B(e,(function(){t++})),t},toArray:function(e){return B(e,(function(e){return e}))||[]},only:function(e){if(!C(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=b,t.Fragment=i,t.Profiler=s,t.PureComponent=k,t.StrictMode=o,t.Suspense=l,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T,t.cloneElement=function(e,t,r){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var i=g({},e.props),o=e.key,s=e.ref,a=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,a=S.current),void 0!==t.key&&(o=""+t.key),e.type&&e.type.defaultProps)var u=e.type.defaultProps;for(c in t)w.call(t,c)&&!j.hasOwnProperty(c)&&(i[c]=void 0===t[c]&&void 0!==u?u[c]:t[c])}var c=arguments.length-2;if(1===c)i.children=r;else if(1<c){u=Array(c);for(var l=0;l<c;l++)u[l]=arguments[l+2];i.children=u}return{$$typeof:n,type:e.type,key:o,ref:s,props:i,_owner:a}},t.createContext=function(e){return(e={$$typeof:u,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:a,_context:e},e.Consumer=e},t.createElement=_,t.createFactory=function(e){var t=_.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:c,render:e}},t.isValidElement=C,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:O}},t.memo=function(e,t){return{$$typeof:p,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=$.transition;$.transition={};try{e()}finally{$.transition=t}},t.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},t.useCallback=function(e,t){return I.current.useCallback(e,t)},t.useContext=function(e){return I.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return I.current.useDeferredValue(e)},t.useEffect=function(e,t){return I.current.useEffect(e,t)},t.useId=function(){return I.current.useId()},t.useImperativeHandle=function(e,t,n){return I.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return I.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return I.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return I.current.useMemo(e,t)},t.useReducer=function(e,t,n){return I.current.useReducer(e,t,n)},t.useRef=function(e){return I.current.useRef(e)},t.useState=function(e){return I.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return I.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return I.current.useTransition()},t.version="18.2.0"},827378:(e,t,n)=>{e.exports=n(541535)},824246:(e,t,n)=>{e.exports=n(371426)},511151:(e,t,n)=>{n.d(t,{Zo:()=>a,ah:()=>o});var r=n(667294);const i=r.createContext({});function o(e){const t=r.useContext(i);return r.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const s={};function a({components:e,children:t,disableParentContext:n}){let a;return a=n?"function"==typeof e?e({}):e||s:o(e),r.createElement(i.Provider,{value:a},t)}}}]);