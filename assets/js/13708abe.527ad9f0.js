/*! For license information please see 13708abe.527ad9f0.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[638427],{389614:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var i=n(824246),r=n(511151);const o={id:"writing-a-policy",title:"Writing a permission policy",description:"How to write your own permission policy as a Backstage integrator"},s=void 0,a={id:"permissions/writing-a-policy",title:"Writing a permission policy",description:"How to write your own permission policy as a Backstage integrator",source:"@site/../docs/permissions/writing-a-policy.md",sourceDirName:"permissions",slug:"/permissions/writing-a-policy",permalink:"/docs/permissions/writing-a-policy",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/permissions/writing-a-policy.md",tags:[],version:"current",frontMatter:{id:"writing-a-policy",title:"Writing a permission policy",description:"How to write your own permission policy as a Backstage integrator"},sidebar:"docs",previous:{title:"Getting Started",permalink:"/docs/permissions/getting-started"},next:{title:"Frontend Integration",permalink:"/docs/permissions/frontend-integration"}},c={},l=[{value:"What&#39;s in a policy?",id:"whats-in-a-policy",level:2},{value:"Conditional decisions",id:"conditional-decisions",level:2},{value:"Resource types",id:"resource-types",level:2}];function u(e){const t={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["In the ",(0,i.jsx)(t.a,{href:"/docs/permissions/getting-started",children:"previous section"}),", we were able to set up the permission framework and make a simple change to our ",(0,i.jsx)(t.code,{children:"TestPermissionPolicy"})," to confirm that policy is indeed wired up correctly."]}),"\n",(0,i.jsx)(t.p,{children:"That policy looked like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",metastring:'title="packages/backend/src/plugins/permission.ts"',children:"class TestPermissionPolicy implements PermissionPolicy {\n  async handle(request: PolicyQuery): Promise<PolicyDecision> {\n    if (request.permission.name === 'catalog.entity.delete') {\n      return {\n        result: AuthorizeResult.DENY,\n      };\n    }\n\n    return { result: AuthorizeResult.ALLOW };\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"whats-in-a-policy",children:"What's in a policy?"}),"\n",(0,i.jsxs)(t.p,{children:["Let's break this down a bit further. The request object of type ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-node.policyquery",children:"PolicyQuery"})," is a simple wrapper around ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.permission",children:"the Permission object"}),". This permission object encapsulates information about the action that the user is attempting to perform (See ",(0,i.jsx)(t.a,{href:"/docs/permissions/concepts",children:"the Concepts page"})," for more details)."]}),"\n",(0,i.jsxs)(t.p,{children:["In the policy above, we are checking to see if the provided action is a catalog entity delete action, which is the permission that the catalog plugin authors have created to represent the action of unregistering a catalog entity. If this is the case, we return a ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.definitivepolicydecision",children:"Definitive Policy Decision"})," of DENY. In all other cases, we return ALLOW (resulting in an allow-by-default behavior)."]}),"\n",(0,i.jsxs)(t.p,{children:["As we confirmed in the previous section, we know that this now prevents us from unregistering catalog components. Hooray! But you may notice that this prevents ",(0,i.jsx)(t.em,{children:"anyone"})," from unregistering a component, which is not a very realistic policy. Let's improve this policy by disabling the unregister action ",(0,i.jsx)(t.em,{children:"unless you are the owner of this component"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"conditional-decisions",children:"Conditional decisions"}),"\n",(0,i.jsx)(t.p,{children:"Let's change the policy to the following:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"/* highlight-remove-next-line */\nimport { IdentityClient } from '@backstage/plugin-auth-node';\n/* highlight-add-start */\nimport {\n  BackstageIdentityResponse,\n  IdentityClient\n} from '@backstage/plugin-auth-node';\n  /* highlight-add-end */\nimport {\n  AuthorizeResult,\n  PolicyDecision,\n  /* highlight-add-next-line */\n  isPermission,\n} from '@backstage/plugin-permission-common';\n/* highlight-add-start */\nimport {\n  catalogConditions,\n  createCatalogConditionalDecision,\n} from '@backstage/plugin-catalog-backend/alpha';\nimport {\n  catalogEntityDeletePermission,\n} from '@backstage/plugin-catalog-common/alpha';\n/* highlight-add-end */\n\nclass TestPermissionPolicy implements PermissionPolicy {\n  /* highlight-remove-next-line */\n  async handle(request: PolicyQuery): Promise<PolicyDecision> {\n  /* highlight-add-start */\n  async handle(\n    request: PolicyQuery,\n    user?: BackstageIdentityResponse,\n   ): Promise<PolicyDecision> {\n  /* highlight-add-end */\n    /* highlight-remove-next-line */\n    if (request.permission.name === 'catalog.entity.delete') {\n    /* highlight-add-next-line */\n    if (isPermission(request.permission, catalogEntityDeletePermission)) {\n      /* highlight-remove-start */\n      return {\n      result: AuthorizeResult.DENY,\n      };\n      /* highlight-remove-end */\n      /* highlight-add-start */\n      return createCatalogConditionalDecision(\n        request.permission,\n        catalogConditions.isEntityOwner({\n          claims: user?.identity.ownershipEntityRefs ?? [],\n        }),\n      );\n      /* highlight-add-end */\n    }\n     return { result: AuthorizeResult.ALLOW };\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Let's walk through the new code that we just added."}),"\n",(0,i.jsxs)(t.p,{children:["Instead of returning an Definitive Policy Decision, we use factory methods to construct a ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.conditionalpolicydecision",children:"Conditional Policy Decision"})," (See the ",(0,i.jsx)(t.a,{href:"/docs/permissions/concepts",children:"Concepts page"})," for more details). Since the policy doesn't have enough information to determine if ",(0,i.jsx)(t.code,{children:"user"})," is the entity owner, this criteria is encapsulated within the conditional decision. However, ",(0,i.jsx)(t.code,{children:"createCatalogConditionalDecision"})," will not compile unless ",(0,i.jsx)(t.code,{children:"request.permission"})," is a catalog entity ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.resourcepermission",children:(0,i.jsx)(t.code,{children:"ResourcePermission"})}),". This type constraint ensures that policies return conditional decisions that are compatible with the requested permission. To address this, we use ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.ispermission",children:(0,i.jsx)(t.code,{children:"isPermission"})})," to ",(0,i.jsx)(t.a,{href:"https://www.typescriptlang.org/docs/handbook/2/narrowing.html",children:'"narrow"'})," the type of ",(0,i.jsx)(t.code,{children:"request.permission"})," to ",(0,i.jsx)(t.code,{children:"ResourcePermission<'catalog-entity'>"}),". This matches the runtime behavior that was in place before, but you'll notice that the type of ",(0,i.jsx)(t.code,{children:"request.permission"})," has changed within the scope of that ",(0,i.jsx)(t.code,{children:"if"})," statement."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"catalogConditions"})," object contains all of the rules defined by the catalog plugin. These rules can be combined to form a ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.permissioncriteria",children:(0,i.jsx)(t.code,{children:"PermissionCriteria"})})," object, but for this case we only need to use the ",(0,i.jsx)(t.code,{children:"isEntityOwner"})," rule. This rule accepts a list of entity refs that represent User identity and Group membership used to determine ownership. The second argument to ",(0,i.jsx)(t.code,{children:"PermissionPolicy#handle"})," provides us with a ",(0,i.jsx)(t.code,{children:"BackstageIdentityResponse"})," object, from which we can grab the user's ",(0,i.jsx)(t.code,{children:"ownershipEntityRefs"}),". We provide an empty array as a fallback since the user may be anonymous."]}),"\n",(0,i.jsx)(t.p,{children:"You should now be able to see in your Backstage app that the unregister entity button is enabled for entities that you own, but disabled for all other entities!"}),"\n",(0,i.jsx)(t.h2,{id:"resource-types",children:"Resource types"}),"\n",(0,i.jsxs)(t.p,{children:["Now let's say we want to prevent all actions on catalog entities unless performed by the owner. One way to achieve this may be to simply update the ",(0,i.jsx)(t.code,{children:"if"})," statement and check for each permission. If you choose to write your policy this way, it will certainly work! However, it may be difficult to maintain as the policy grows, and it may not be obvious if certain permissions are left out. We can author this same policy in a more scalable way by checking the resource type of the requested permission."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import {\n  AuthorizeResult,\n  PolicyDecision,\n  /* highlight-remove-next-line */\n  isPermission,\n  isResourcePermission,\n  /* highlight-add-next-line */\n} from '@backstage/plugin-permission-common';\nimport {\n  catalogConditions,\n  createCatalogConditionalDecision,\n} from '@backstage/plugin-catalog-backend/alpha';\n/* highlight-remove-start */\nimport {\n  catalogEntityDeletePermission,\n} from '@backstage/plugin-catalog-common/alpha';\n/* highlight-remove-end */\n\nclass TestPermissionPolicy implements PermissionPolicy {\n  async handle(\n    request: PolicyQuery,\n    user?: BackstageIdentityResponse,\n  ): Promise<PolicyDecision> {\n    /* highlight-remove-next-line */\n    if (isPermission(request.permission, catalogEntityDeletePermission)) {\n    /* highlight-add-next-line */\n    if (isResourcePermission(request.permission, 'catalog-entity')) {\n      return createCatalogConditionalDecision(\n        request.permission,\n        catalogConditions.isEntityOwner({\n          claims: user?.identity.ownershipEntityRefs ?? [],\n        }),\n      );\n    }\n\n    return { result: AuthorizeResult.ALLOW };\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In this example, we use ",(0,i.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.isresourcepermission",children:(0,i.jsx)(t.code,{children:"isResourcePermission"})})," to match all permissions with a resource type of ",(0,i.jsx)(t.code,{children:"catalog-entity"}),". Just like ",(0,i.jsx)(t.code,{children:"isPermission"}),', this helper will "narrow" the type of ',(0,i.jsx)(t.code,{children:"request.permission"})," and enable the use of ",(0,i.jsx)(t.code,{children:"createCatalogConditionalDecision"}),". In addition to the behavior you observed before, you should also see that catalog entities are no longer visible unless you are the owner - success!"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.em,{children:"Note:"})," Some catalog permissions do not have the ",(0,i.jsx)(t.code,{children:"'catalog-entity'"})," resource type, such as ",(0,i.jsx)(t.a,{href:"https://github.com/backstage/backstage/blob/1e5e9fb9de9856a49e60fc70c38a4e4e94c69570/plugins/catalog-common/src/permissions.ts#L49",children:(0,i.jsx)(t.code,{children:"catalogEntityCreatePermission"})}),". In those cases, a definitive decision is required because conditions can't be applied to an entity that does not exist yet."]})]})}function h(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},371426:(e,t,n)=>{var i=n(827378),r=Symbol.for("react.element"),o=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,a=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var i,o={},l=null,u=null;for(i in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)s.call(t,i)&&!c.hasOwnProperty(i)&&(o[i]=t[i]);if(e&&e.defaultProps)for(i in t=e.defaultProps)void 0===o[i]&&(o[i]=t[i]);return{$$typeof:r,type:e,key:l,ref:u,props:o,_owner:a.current}}t.Fragment=o,t.jsx=l,t.jsxs=l},541535:(e,t)=>{var n=Symbol.for("react.element"),i=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),o=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,y={};function g(e,t,n){this.props=e,this.context=t,this.refs=y,this.updater=n||f}function b(){}function w(e,t,n){this.props=e,this.context=t,this.refs=y,this.updater=n||f}g.prototype.isReactComponent={},g.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},g.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=g.prototype;var v=w.prototype=new b;v.constructor=w,m(v,g.prototype),v.isPureReactComponent=!0;var x=Array.isArray,j=Object.prototype.hasOwnProperty,k={current:null},P={key:!0,ref:!0,__self:!0,__source:!0};function _(e,t,i){var r,o={},s=null,a=null;if(null!=t)for(r in void 0!==t.ref&&(a=t.ref),void 0!==t.key&&(s=""+t.key),t)j.call(t,r)&&!P.hasOwnProperty(r)&&(o[r]=t[r]);var c=arguments.length-2;if(1===c)o.children=i;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];o.children=l}if(e&&e.defaultProps)for(r in c=e.defaultProps)void 0===o[r]&&(o[r]=c[r]);return{$$typeof:n,type:e,key:s,ref:a,props:o,_owner:k.current}}function C(e){return"object"==typeof e&&null!==e&&e.$$typeof===n}var R=/\/+/g;function E(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function S(e,t,r,o,s){var a=typeof e;"undefined"!==a&&"boolean"!==a||(e=null);var c=!1;if(null===e)c=!0;else switch(a){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case i:c=!0}}if(c)return s=s(c=e),e=""===o?"."+E(c,0):o,x(s)?(r="",null!=e&&(r=e.replace(R,"$&/")+"/"),S(s,t,r,"",(function(e){return e}))):null!=s&&(C(s)&&(s=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(s,r+(!s.key||c&&c.key===s.key?"":(""+s.key).replace(R,"$&/")+"/")+e)),t.push(s)),1;if(c=0,o=""===o?".":o+":",x(e))for(var l=0;l<e.length;l++){var u=o+E(a=e[l],l);c+=S(a,t,r,u,s)}else if(u=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"==typeof u)for(e=u.call(e),l=0;!(a=e.next()).done;)c+=S(a=a.value,t,r,u=o+E(a,l++),s);else if("object"===a)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function D(e,t,n){if(null==e)return e;var i=[],r=0;return S(e,i,"","",(function(e){return t.call(n,e,r++)})),i}function I(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var O={current:null},q={transition:null},T={ReactCurrentDispatcher:O,ReactCurrentBatchConfig:q,ReactCurrentOwner:k};t.Children={map:D,forEach:function(e,t,n){D(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return D(e,(function(){t++})),t},toArray:function(e){return D(e,(function(e){return e}))||[]},only:function(e){if(!C(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=g,t.Fragment=r,t.Profiler=s,t.PureComponent=w,t.StrictMode=o,t.Suspense=u,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=T,t.cloneElement=function(e,t,i){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=m({},e.props),o=e.key,s=e.ref,a=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,a=k.current),void 0!==t.key&&(o=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(l in t)j.call(t,l)&&!P.hasOwnProperty(l)&&(r[l]=void 0===t[l]&&void 0!==c?c[l]:t[l])}var l=arguments.length-2;if(1===l)r.children=i;else if(1<l){c=Array(l);for(var u=0;u<l;u++)c[u]=arguments[u+2];r.children=c}return{$$typeof:n,type:e.type,key:o,ref:s,props:r,_owner:a}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:a,_context:e},e.Consumer=e},t.createElement=_,t.createFactory=function(e){var t=_.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:l,render:e}},t.isValidElement=C,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:I}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=q.transition;q.transition={};try{e()}finally{q.transition=t}},t.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},t.useCallback=function(e,t){return O.current.useCallback(e,t)},t.useContext=function(e){return O.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return O.current.useDeferredValue(e)},t.useEffect=function(e,t){return O.current.useEffect(e,t)},t.useId=function(){return O.current.useId()},t.useImperativeHandle=function(e,t,n){return O.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return O.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return O.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return O.current.useMemo(e,t)},t.useReducer=function(e,t,n){return O.current.useReducer(e,t,n)},t.useRef=function(e){return O.current.useRef(e)},t.useState=function(e){return O.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return O.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return O.current.useTransition()},t.version="18.2.0"},827378:(e,t,n)=>{e.exports=n(541535)},824246:(e,t,n)=>{e.exports=n(371426)},511151:(e,t,n)=>{n.d(t,{Z:()=>a,a:()=>s});var i=n(667294);const r={},o=i.createContext(r);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);