/*! For license information please see 8e12954d.a4a3d447.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[630848],{564677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>u});var r=n(824246),o=n(511151);const i={id:"04-authorizing-access-to-paginated-data",title:"4. Authorizing access to paginated data",description:"Explains how to authorize access to paginated data in a Backstage plugin"},s=void 0,a={id:"permissions/plugin-authors/04-authorizing-access-to-paginated-data",title:"4. Authorizing access to paginated data",description:"Explains how to authorize access to paginated data in a Backstage plugin",source:"@site/../docs/permissions/plugin-authors/04-authorizing-access-to-paginated-data.md",sourceDirName:"permissions/plugin-authors",slug:"/permissions/plugin-authors/04-authorizing-access-to-paginated-data",permalink:"/docs/permissions/plugin-authors/04-authorizing-access-to-paginated-data",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/../docs/permissions/plugin-authors/04-authorizing-access-to-paginated-data.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"04-authorizing-access-to-paginated-data",title:"4. Authorizing access to paginated data",description:"Explains how to authorize access to paginated data in a Backstage plugin"},sidebar:"docs",previous:{title:"3. Adding a resource permission check",permalink:"/docs/permissions/plugin-authors/03-adding-a-resource-permission-check"},next:{title:"5. Frontend Components with Authorization",permalink:"/docs/permissions/plugin-authors/05-frontend-authorization"}},c={},u=[{value:"Creating the read permission",id:"creating-the-read-permission",level:2},{value:"Using conditional policy decisions",id:"using-conditional-policy-decisions",level:2},{value:"Test the authorized read endpoint",id:"test-the-authorized-read-endpoint",level:2}];function l(e){const t=Object.assign({p:"p",code:"code",pre:"pre",blockquote:"blockquote",a:"a",h2:"h2"},(0,o.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["Authorizing ",(0,r.jsx)(t.code,{children:"GET /todos"})," is similar to the update endpoint, in that it should be possible to authorize access based on the characteristics of each resource. However, we'll need to authorize a list of resources for this endpoint."]}),"\n",(0,r.jsxs)(t.p,{children:["One possible solution may leverage the batching functionality to authorize all of the todos, and then returning only the ones for which the decision was ",(0,r.jsx)(t.code,{children:"ALLOW"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"router.get('/todos', async (req, res) => {\n  /* highlight-add-next-line */\n  const token = IdentityClient.getBearerToken(req.header('authorization'));\n\n  /* highlight-remove-next-line */\n  res.json(getAll());\n  /* highlight-add-start */\n  const items = getAll();\n  const decisions = await permissions.authorize(\n    items.map(({ id }) => ({\n      permission: todoListReadPermission,\n      resourceRef: id,\n    })),\n  );\n\n  const filteredItems = decisions.filter(\n    decision => decision.result === AuthorizeResult.ALLOW,\n  );\n  res.json(filteredItems);\n  /* highlight-add-end */\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"This approach will work for simple cases, but it has a downside: it forces us to retrieve all the elements upfront and authorize them one by one. This forces the plugin implementation to handle concerns like pagination, which is currently handled by the data source."}),"\n",(0,r.jsx)(t.p,{children:"To avoid this situation, the permissions framework has support for filtering items in the data source itself. In this part of the tutorial, we'll describe the steps required to use that behavior."}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["Note: in order to perform authorization filtering in this way, the data source must allow filters to be logically combined with AND, OR, and NOT operators. The conditional decisions returned by the permissions framework use a ",(0,r.jsx)(t.a,{href:"https://backstage.io/docs/reference/plugin-permission-common.permissioncriteria",children:"nested object"})," to combine conditions. If you're implementing a filter API from scratch, we recommend using the same shape for ease of interoperability. If not, you'll need to implement a function which transforms the nested object into your own format."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"creating-the-read-permission",children:"Creating the read permission"}),"\n",(0,r.jsx)(t.p,{children:"Let's add another permission to the plugin."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="plugins/todo-list-backend/src/service/permissions.ts"',children:"import { createPermission } from '@backstage/plugin-permission-common';\n\nexport const TODO_LIST_RESOURCE_TYPE = 'todo-item';\n\nexport const todoListCreatePermission = createPermission({\n  name: 'todo.list.create',\n  attributes: { action: 'create' },\n});\n\nexport const todoListUpdatePermission = createPermission({\n  name: 'todo.list.update',\n  attributes: { action: 'update' },\n  resourceType: TODO_LIST_RESOURCE_TYPE,\n});\n\n/* highlight-add-start */\nexport const todoListReadPermission = createPermission({\n  name: 'todos.list.read',\n  attributes: { action: 'read' },\n  resourceType: TODO_LIST_RESOURCE_TYPE,\n});\n/* highlight-add-end */\n\nexport const todoListPermissions = [\n  todoListCreatePermission,\n  todoListUpdatePermission,\n  /* highlight-add-start */\n  todoListReadPermission,\n  /* highlight-add-end */\n];\n"})}),"\n",(0,r.jsx)(t.h2,{id:"using-conditional-policy-decisions",children:"Using conditional policy decisions"}),"\n",(0,r.jsxs)(t.p,{children:["So far we've only used the ",(0,r.jsx)(t.code,{children:"PermissionEvaluator.authorize"})," method, which will evaluate conditional decisions before returning a result. In this step, we want to evaluate conditional decisions within our plugin, so we'll use ",(0,r.jsx)(t.code,{children:"PermissionEvaluator.authorizeConditional"})," instead."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="plugins/todo-list-backend/src/service/router.ts"',children:"/* highlight-remove-next-line */\nimport { createPermissionIntegrationRouter } from '@backstage/plugin-permission-node';\n/* highlight-add-start */\nimport {\n  createPermissionIntegrationRouter,\n  createConditionTransformer,\n  ConditionTransformer,\n} from '@backstage/plugin-permission-node';\n/* highlight-add-end */\n/* highlight-remove-next-line */\nimport { add, getAll, getTodo, update } from './todos';\n/* highlight-add-next-line */\nimport { add, getAll, getTodo, TodoFilter, update } from './todos';\nimport {\n  TODO_LIST_RESOURCE_TYPE,\n  todoListCreatePermission,\n  todoListUpdatePermission,\n  /* highlight-add-next-line */\n  todoListReadPermission,\n} from './permissions';\n\n// ...\n\nconst permissionIntegrationRouter = createPermissionIntegrationRouter({\n  /* highlight-remove-next-line */\n  permissions: [todoListCreatePermission, todoListUpdatePermission],\n  /* highlight-add-next-line */\n  permissions: [todoListCreatePermission, todoListUpdatePermission, todoListReadPermission],\n  getResources: async resourceRefs => {\n    return resourceRefs.map(getTodo);\n  },\n  resourceType: TODO_LIST_RESOURCE_TYPE,\n  rules: Object.values(rules),\n});\n\n// ...\n\n/* highlight-add-next-line */\nconst transformConditions: ConditionTransformer<TodoFilter> = createConditionTransformer(Object.values(rules));\n\n/* highlight-remove-next-line */\nrouter.get('/todos', async (_req, res) => {\n/* highlight-add-start */\nrouter.get('/todos', async (req, res) => {\n  const token = getBearerTokenFromAuthorizationHeader(\n    req.header('authorization'),\n  );\n\n  const decision = (\n    await permissions.authorizeConditional([{ permission: todoListReadPermission }], {\n      token,\n    })\n  )[0];\n\n  if (decision.result === AuthorizeResult.DENY) {\n    throw new NotAllowedError('Unauthorized');\n  }\n\n  if (decision.result === AuthorizeResult.CONDITIONAL) {\n    const filter = transformConditions(decision.conditions);\n    res.json(getAll(filter));\n  } else {\n    res.json(getAll());\n  }\n/* highlight-add-end */\n  /* highlight-remove-next-line */\n  res.json(getAll());\n});\n"})}),"\n",(0,r.jsxs)(t.p,{children:["To make the process of handling conditional decisions easier, the permission framework provides a ",(0,r.jsx)(t.code,{children:"createConditionTransformer"})," helper. This function accepts an array of permission rules, and returns a transformer function which converts the conditions to the format needed by the plugin using the ",(0,r.jsx)(t.code,{children:"toQuery"})," method defined on each rule."]}),"\n",(0,r.jsxs)(t.p,{children:["Since ",(0,r.jsx)(t.code,{children:"TodoFilter"})," used in our plugin matches the structure of the conditions object, we can directly pass the output of our condition transformer. If the filters were structured differently, we'd need to transform it further before passing it to the api."]}),"\n",(0,r.jsx)(t.h2,{id:"test-the-authorized-read-endpoint",children:"Test the authorized read endpoint"}),"\n",(0,r.jsxs)(t.p,{children:["Let's update our permission policy to return a conditional result whenever a ",(0,r.jsx)(t.code,{children:"todoListReadPermission"})," permission is received. In this case, we can reuse the decision returned for the ",(0,r.jsx)(t.code,{children:"todosListCreate"})," permission."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="packages/backend/src/plugins/permission.ts"',children:"import {\n  todoListCreatePermission,\n  todoListUpdatePermission,\n  /* highlight-add-next-line */\n  todoListReadPermission,\n} from '@internal/plugin-todo-list-common';\n\n/* highlight-remove-next-line */\nif (isPermission(request.permission, todoListUpdatePermission)) {\n/* highlight-add-start */\nif (\n  isPermission(request.permission, todoListUpdatePermission) ||\n  isPermission(request.permission, todoListReadPermission)\n) {\n/* highlight-add-end */\n  return createTodoListConditionalDecision(\n    request.permission,\n    todoListConditions.isOwner({\n      userId: user?.identity.userEntityRef\n    }),\n  );\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"Once the changes to the permission policy are saved, the UI should show only the todo items you've created."})]})}const d=function(e={}){const{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?(0,r.jsx)(t,Object.assign({},e,{children:(0,r.jsx)(l,e)})):l(e)}},371426:(e,t,n)=>{var r=n(827378),o=Symbol.for("react.element"),i=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,a=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var r,i={},u=null,l=null;for(r in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(l=t.ref),t)s.call(t,r)&&!c.hasOwnProperty(r)&&(i[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps)void 0===i[r]&&(i[r]=t[r]);return{$$typeof:o,type:e,key:u,ref:l,props:i,_owner:a.current}}t.Fragment=i,t.jsx=u,t.jsxs=u},541535:(e,t)=>{var n=Symbol.for("react.element"),r=Symbol.for("react.portal"),o=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),c=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!=typeof e&&"function"!=typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var _=v.prototype=new b;_.constructor=v,m(_,y.prototype),_.isPureReactComponent=!0;var x=Array.isArray,w=Object.prototype.hasOwnProperty,j={current:null},k={key:!0,ref:!0,__self:!0,__source:!0};function P(e,t,r){var o,i={},s=null,a=null;if(null!=t)for(o in void 0!==t.ref&&(a=t.ref),void 0!==t.key&&(s=""+t.key),t)w.call(t,o)&&!k.hasOwnProperty(o)&&(i[o]=t[o]);var c=arguments.length-2;if(1===c)i.children=r;else if(1<c){for(var u=Array(c),l=0;l<c;l++)u[l]=arguments[l+2];i.children=u}if(e&&e.defaultProps)for(o in c=e.defaultProps)void 0===i[o]&&(i[o]=c[o]);return{$$typeof:n,type:e,key:s,ref:a,props:i,_owner:j.current}}function R(e){return"object"==typeof e&&null!==e&&e.$$typeof===n}var E=/\/+/g;function C(e,t){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function T(e,t,o,i,s){var a=typeof e;"undefined"!==a&&"boolean"!==a||(e=null);var c=!1;if(null===e)c=!0;else switch(a){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case r:c=!0}}if(c)return s=s(c=e),e=""===i?"."+C(c,0):i,x(s)?(o="",null!=e&&(o=e.replace(E,"$&/")+"/"),T(s,t,o,"",(function(e){return e}))):null!=s&&(R(s)&&(s=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(s,o+(!s.key||c&&c.key===s.key?"":(""+s.key).replace(E,"$&/")+"/")+e)),t.push(s)),1;if(c=0,i=""===i?".":i+":",x(e))for(var u=0;u<e.length;u++){var l=i+C(a=e[u],u);c+=T(a,t,o,l,s)}else if(l=function(e){return null===e||"object"!=typeof e?null:"function"==typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"==typeof l)for(e=l.call(e),u=0;!(a=e.next()).done;)c+=T(a=a.value,t,o,l=i+C(a,u++),s);else if("object"===a)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function O(e,t,n){if(null==e)return e;var r=[],o=0;return T(e,r,"","",(function(e){return t.call(n,e,o++)})),r}function S(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var L={current:null},z={transition:null},I={ReactCurrentDispatcher:L,ReactCurrentBatchConfig:z,ReactCurrentOwner:j};t.Children={map:O,forEach:function(e,t,n){O(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return O(e,(function(){t++})),t},toArray:function(e){return O(e,(function(e){return e}))||[]},only:function(e){if(!R(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=o,t.Profiler=s,t.PureComponent=v,t.StrictMode=i,t.Suspense=l,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=I,t.cloneElement=function(e,t,r){if(null==e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var o=m({},e.props),i=e.key,s=e.ref,a=e._owner;if(null!=t){if(void 0!==t.ref&&(s=t.ref,a=j.current),void 0!==t.key&&(i=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(u in t)w.call(t,u)&&!k.hasOwnProperty(u)&&(o[u]=void 0===t[u]&&void 0!==c?c[u]:t[u])}var u=arguments.length-2;if(1===u)o.children=r;else if(1<u){c=Array(u);for(var l=0;l<u;l++)c[l]=arguments[l+2];o.children=c}return{$$typeof:n,type:e.type,key:i,ref:s,props:o,_owner:a}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:a,_context:e},e.Consumer=e},t.createElement=P,t.createFactory=function(e){var t=P.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=R,t.lazy=function(e){return{$$typeof:h,_payload:{_status:-1,_result:e},_init:S}},t.memo=function(e,t){return{$$typeof:d,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=z.transition;z.transition={};try{e()}finally{z.transition=t}},t.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},t.useCallback=function(e,t){return L.current.useCallback(e,t)},t.useContext=function(e){return L.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return L.current.useDeferredValue(e)},t.useEffect=function(e,t){return L.current.useEffect(e,t)},t.useId=function(){return L.current.useId()},t.useImperativeHandle=function(e,t,n){return L.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return L.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return L.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return L.current.useMemo(e,t)},t.useReducer=function(e,t,n){return L.current.useReducer(e,t,n)},t.useRef=function(e){return L.current.useRef(e)},t.useState=function(e){return L.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return L.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return L.current.useTransition()},t.version="18.2.0"},827378:(e,t,n)=>{e.exports=n(541535)},824246:(e,t,n)=>{e.exports=n(371426)},511151:(e,t,n)=>{n.d(t,{Zo:()=>a,ah:()=>i});var r=n(667294);const o=r.createContext({});function i(e){const t=r.useContext(o);return r.useMemo((()=>"function"==typeof e?e(t):{...t,...e}),[t,e])}const s={};function a({components:e,children:t,disableParentContext:n}){let a;return a=n?"function"==typeof e?e({}):e||s:i(e),r.createElement(o.Provider,{value:a},t)}}}]);